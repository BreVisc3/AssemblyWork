Test date: 11/18/24  23:11:46 
The number of times you used the grading program is 2 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
RLC Grading System Version 4.0
Student: Last=Viscount             First=Brendan              Type=Individual          
Grading and testing history log
       User Test.    Date: 11/13/24  19:34:57  1            Display      
       User Test.    Date: 11/13/24  19:35:45  2            Display      
       User Test.    Date: 11/14/24  19:30:31  1            Display      
       User Test.    Date: 11/14/24  19:30:41  2            Display      
       User Test.    Date: 11/14/24  19:30:43  3            Display      
       User Test.    Date: 11/15/24  13:54:20  1            Display      
       User Test.    Date: 11/18/24  19:27:39  1            Display      
       User Test.    Date: 11/18/24  19:51:05  1            Display      
       User Test.    Date: 11/18/24  20:02:59  2            Display      
       User Test.    Date: 11/18/24  22:32:07  1            Display      
       User Test.    Date: 11/18/24  22:32:10  2            Display      
       User Test.    Date: 11/18/24  22:32:14  3            Display      
   *** Grading Run.  Date: 11/18/24  22:32:28 
       User Test.    Date: 11/18/24  23:03:53  1            Display      
       User Test.    Date: 11/18/24  23:10:38  1            Display      
       User Test.    Date: 11/18/24  23:11:39  1            Display      
   *** Grading Run.  Date: 11/18/24  23:11:46 

Testing 1 dimension compression
Your output is correct
Your output is correct
Your output is correct

+  Your executed instruction count for tests run = 00006072
+   
+  Target instructions executed for tests run is:
+  20 points 00000 - 07999 
+  15 points 08000 - 09999 
+  10 points 10000 - 11999 
+   5 points 12000 - 13999 
+   0 points 14001 +       
+                          

++ Grade ++   20 = Points earned for code executed efficiency!

1 dimension compression is working

The following is credit earned for 1-dim compression

++ Grade ++  040 = Points earned for correct answers.

-> We are now analyzing your source code. You will be graded on
the number of instructions you wrote to solve this problem.
The target for the number of executable instructions written is:
 00 -  44 = 20 points 
 45 -  49 = 15 points 
 50 -  54 = 10 points 
 55 -  59 =  5 points 
 60+      =  0 points 
Your actual counts are:
Lines ....... 139    Comments ...  68    Labels .......   7   
Directives ..   6    Variables ..   4    Executables ..  54    McCabe ..   4 
++ Grade ++   10 = Points earned for code written efficiency.  

-> Analyzing program documentation. 
The heuristic algorithms used may have problems with your specific code. 
Contact the instructor if you detect a problem with your grade. 
DOCPH-0015 The program header format is adequate. 
DOCHB-0.43 Use of code blocks headers is marginal, -5 points. 
           Programs must be broken into small functional blocks of code.     
           Each block must have a header that describes the code's function. 
           See the Program Documentation Requirements on the WEB.            
DOCLC-0.85 Use of line comments is adequate. 
++ Grade ++   15 = Points earned for correct documentation.    

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++   85 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
    15  = Number of user tests.                                  
     2  = Number of grading runs to get the program working.     
     0  = Number of grading runs to improve efficiency or documentation. 

+- atyC:6&}xC76&k~C86&juiC7;&zuzC>;&Zkyz&jgzk@&7757>58:&&89@77@:<&

Building the file rlc.ans for electronic submission...

;---------------------------------------------------------------------
;  Program:      Run Length Coding
;
;  Function:     Decompresses 1 dimensional run lengths
;                This subroutine links with a C main program
;
;                Add your additional functional comments
;
;  Owner:		 Brendan Viscount
;
;  Changes:
;  Date          Reason
;  ----          ------
;  05/16/2017    Original version ... coded to spec design
;---------------------------------------------------------------------
         .model    small
         .8086
         public    _rlc
;---------------------------------------
         .data                         ;start the data segment
;---------------------------------------

	white db 20h    					;white character
	black db 0DBh   					;black character
	linelength dw 50h                   ;line Length
	fillflag db 0Fh

;---------------------------------------
         .code                         ;start the code segnment
;---------------------------------------
; Save the registers ... 'C' requires (bp,si,di)
; Access the input and output lists
;---------------------------------------
_rlc:                                  ;
         push      bp                  ;save 'C' register
         mov       bp,sp               ;set bp to point to stack
         push      si                  ;save 'C' register
         push      di                  ;save 'C' register
		 push      dx           	   ;save 'C' register
		 push      cx                  ;save 'C' register
		 push      bx                  ;save 'C' register
		 push      ax				   ;save 'C' register
         mov       si,[bp+4]           ;si points to the input compressed data
         mov       di,[bp+6]           ;di points to the empty output buffer
;---------------------------------------
;     PREPARE DATA FOR PROCCESSING
;---------------------------------------

		 mov       ax, ds              ; Set Data segment address to extra
		 mov       es, ax				
		 cld                           ; set direction flag for lodsb and stosb to increment
		 
newline: 
		 mov       dx, [linelength]    ; reset remaining spaces
		 mov       bx, 0DB20h          ; Color data storage [black][white]
;---------------------------------------
;     LOAD DATA FOR 2 RUNS INTO AL
;---------------------------------------
process_next:
		 lodsb                         ; Load from si to al
		 
		 cmp       al, 00h             ; Compare to end of input marker
		 je        exit                ; Jump to end
		 
;---------------------------------------
;     READING FIRST RUN FOR BYTE
;---------------------------------------
		 mov       cx, 4               ; load into shiftable reg
		 mov       ah, al              ; Preserve byte data in AH
		 shr       al, cl              ; Shift the upper four bits of al to get the first run length
		 
		 mov       cl, al              ; Set first length to loop counter register 
		 mov       al, bl             ; Move current color char into reg used by stosb
		 
		 cmp        cl, 00Fh           ; compare to fill byte
		 je         fill_first         ; jump to fill line   <- IF I'M USING 2 LABELS
		 
		 sub       dx, cx              ; Adjust remaining spaces
		 
		 rep stosb                     ; store AL to DI 
		 xchg       bl, bh             ; Toggle color (switch between 20h and DBh)
		 
;---------------------------------------
;     READING SECOND RUN FOR BYTE
;---------------------------------------		 
read_second:
		 mov        al, ah              ; Load preserved byte into AL
		 and        al, 0Fh             ; Mask to preserve lower 4 bits (second run)
		 
		 mov        cl, al              ; Set counter for second
		 mov        al, bl              ; Set current color to
		 
		 cmp        cl, 00Fh            ; compare to fill byte
		 je         fill_remaining      ; jump to fill line 
		 
		 sub        dx, cx              ; Adjust remaining spaces
		 
		 rep stosb                     ; store Al to DI, CX times
		 xchg       bl, bh             ; Toggle color
		 jmp        process_next       ; Repeat for next byte
		 

;---------------------------------------
;     FILL THE REST OF LINE 
;---------------------------------------
fill_first:
		 ;;;MAYBE USE EXTRA LABEL TO DETERMINE WHERE TO JUMP AFTER
		 mov       cx, dx              ; set remaining spaces into cx
         rep stosb                     ; Fill the remaining space with the current color
		 mov       bx, 0DB20h          ; Color data storage [black][white]
		 mov       dx, [linelength]    ; reset remaining spaces
		 jmp       read_second         ; go to processing the lower 4 bits
fill_remaining:

         mov       cx, dx              ; set remaining spaces into cx
         rep stosb                     ; Fill the remaining space with the current color
		 jmp       newline             ; 
		 
		 ;;;FIGURE OUT IF FIRST OR SECOND BYTE WAS FILL
		 
		; and       ah, 0Fh             ; Mask to preserve lower 4 bits (second run)
		; cmp       ah, 
		; je        read_second         ; jump to read second byte if fill was the high 4 bits
		; jmp       process_next		 ; if fill character was in higher 4 bits jmp read_second

;---------------------------------------
;     RESTORE REGISTERS AND RETURN
;---------------------------------------
exit:
         pop       ax                  ; Restore registers
		 pop	   bx
		 pop       cx
         pop       dx
         pop       di
         pop       si
         pop       bp
         ret                           ; Return
;---------------------------------------
         end