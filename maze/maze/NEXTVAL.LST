Microsoft (R) Macro Assembler Version 6.11		    10/22/24 13:52:55
nextval.asm						     Page 1 - 1


				;---------------------------------------------------------------------
				; Program:   nextval subroutine
				;
				; Function:  Find next mouse move in an array 15 by 30.
				;            We can move into a position if its contents is blank ( 20h ).
				;
				; Input:     Calling sequence is:
				;            x    pointer   si
				;            y    pointer   di
				;            dir  pointer   bx
				;            maze pointer   bp
				;
				; Output:    x,y,dir modified in caller's data segment
				;
				; Owner:     Dana A. Lasher
				;
				; Date:      Update Reason
				; --------------------------
				; 11/06/2016 Original version
				;
				;
				;---------------------------------------
				         .model    small               ;64k code and 64k data
				         .8086                         ;only allow 8086 instructions
				         public    nextval             ;allow extrnal programs to call
				;---------------------------------------


				;---------------------------------------
 0000				         .data                         ;start the data segment
					
					
 0000 1E				column db 30					   ; Width of columns
						 
				;---------------------------------------
 0000				         .code                         ;start the code segment
				;---------------------------------------
				; Save any modified registers
				;---------------------------------------
 0000				nextval:                               ;
				    ; Input: 
				    ; bp -> maze address
				    ; di -> pointer to current y (1-15)
				    ; si -> pointer to current x (1-30)
				    ; bx -> pointer to current direction (1-4)                                   ;
				                                       ;
				;---------------------------------------
				; Code to make 1 move in the maze
				;---------------------------------------
				    ; Load Y and X from pointers into mouse_data
					; Push used registers to maintain for caller
					
				;----------------------------------------------------
				; SAVE REGISTERS TO RESTORE FOR CALLER
				;----------------------------------------------------
 0000  50				push ax 										 ; Preserve register ax
 0001  52				push dx 										 ; Preserve register dx 
 0002  56				push si 										 ; Preserve register si 
 0003  53				push bx 										 ; Preserve register bx 
					
				;----------------------------------------------------

				; FIND OFFSET IN MEMORY BASED ON COORDINATES

				;----------------------------------------------------
 0004  B6 00				mov dh, 0										 ; Clear dh for offset 
 0006  8A 14			    mov dl, byte ptr [si]                       	 ; Get current X
				;----------------------------------------------------	
				; CHANGE COORDINATE TO 0-BASED FOR OFFSET CALCULATION
				;----------------------------------------------------
 0008  FE 0D				dec byte ptr [di]                  				 ; Convert Y to 0-based (Y - 1)
 000A  4A			    dec dx                             				 ; Convert X to 0-based (X - 1)
				;----------------------------------------------------	
				; MULTIPLY (Y-1) BY COLUMN WIDTH TO MOVE TO CORRECT ROW
				;----------------------------------------------------
 000B  8A 05				mov al, [di]                       				 ; Move Y to DL to use it for multiplication
 000D  8A 1E 0000 R			mov bl, [column]                   				 ; Load the column count (30) into BL
 0011  F6 E3			    mul bl       					   				 ; DL * BL -> AX = (Y - 1) * 30
				;----------------------------------------------------	
				; ADD (X-1) TO PRODUCT TO MOVE TO CORRECT COLUMN IN ROW
				;----------------------------------------------------
 0013  8B F0				mov si, ax						   				 ; store in a register that can be used for offset
 0015  03 F2				add si, dx                         				 ; Final offset: (Y - 1) * 30 + (X - 1) stored in SI
 0017  5B				pop bx                             			     ; move bx back to original position to use for direction checking

				;----------------------------------------------------	
				; CHECK DIRECTION
				;----------------------------------------------------
 0018				moves:											     ; cycle check directions
 0018  80 3F 01				cmp byte ptr [bx], 1 							 ; EAST
 001B  74 13				je moveDown								 		 ; Right from east is Down (south)
 001D  80 3F 02				cmp byte ptr [bx], 2			       			 ; SOUTH
 0020  74 17				je moveLeft						         		 ; Right from south is Left (west)
 0022  80 3F 03				cmp byte ptr [bx], 3 							 ; WEST
 0025  74 1B				je moveUp										 ; Right from west is Up (north)
					
				;----------------------------------------------------	

				; CHECK FOR OPEN SPACE

				;----------------------------------------------------

				;----------------------------------------------------	
				; CHECK EAST
				;----------------------------------------------------
 0027				moveRight:
 0027  3E: 80 7A 01 20			cmp byte ptr ds:[bp + si + 1], 20h			    ; Check the position to the right
 002C  74 23				je moveR										; Equals? jmp to move
 002E  EB 12				jmp moveUp										; move to next direction
				;----------------------------------------------------	
				; CHECK SOUTH
				;----------------------------------------------------
 0030				moveDown:
 0030  3E: 80 7A 1E 20		    cmp byte ptr ds:[bp + si + 30], 20h             ; Check the down position using BL
 0035  74 22				je moveD										; Equals? jmp to move
 0037  EB EE				jmp moveRight									; move to next direction
				;----------------------------------------------------	
				; CHECK WEST
				;----------------------------------------------------
 0039				moveLeft:
 0039  3E: 80 7A FF 20			cmp byte ptr ds:[bp + si - 1], 20h				; Check the position to the left
 003E  74 21				je moveL										; move to next direction
 0040  EB EE				jmp moveDown
				;----------------------------------------------------	
				; CHECK NORTH
				;----------------------------------------------------
 0042				moveUp:
 0042  3E: 80 7A E2 20			cmp byte ptr ds:[bp + si - 30], 20h		    	; Check the position above
 0047  75 F0				jne moveLeft								    ; If it's equal let if fall through

				;---------------------------------------------------

				; ALTER X and Y COORDINATES TO BE RETURNED	

				;---------------------------------------------------

				;----------------------------------------------------	
				; MOVE NORTH
				;----------------------------------------------------
 0049				moveU:
 0049  5E				pop si											; Restore register si
 004A  FE 0D				dec byte ptr [di]  		                		; decrement y to move up
 004C  C6 07 04				mov byte ptr [bx], 4							; set direction moved
 004F  EB 16				jmp exit										; Jump to end of function call because move was made
				;----------------------------------------------------	
				; MOVE EAST
				;----------------------------------------------------
 0051				moveR:												
 0051  5E			    pop si											; Restore register si
 0052  FE 04				inc byte ptr [si]  		                		; increment x to move right
 0054  C6 07 01				mov byte ptr [bx], 1							; set direction moved
 0057  EB 0E				jmp exit										; Jump to end of function call because move was made
				;----------------------------------------------------	
				; MOVE SOUTH
				;----------------------------------------------------
 0059				moveD:
 0059  5E				pop si											; Restore register si
 005A  FE 05				inc byte ptr [di]  		                		; increment y to move down    
 005C  C6 07 02				mov byte ptr [bx], 2							; set direction moved
 005F  EB 06				jmp exit										; Jump to end of function call because move was made
				;----------------------------------------------------	
				; MOVE WEST
				;----------------------------------------------------
 0061				moveL:
 0061  5E				pop si											; Restore register si
 0062  FE 0C				dec byte ptr [si]  		                		; decrement x to move left
 0064  C6 07 03				mov byte ptr [bx], 3							; set direction moved
					
				;---------------------------------------
				; Restore registers and return
				;---------------------------------------
 0067				exit:   
 0067  5A				pop dx											; Restore register dx
 0068  58				pop ax											; Restore register ax 
 0069  FE 05				inc byte ptr [di]                     
				                                       ;
 006B  C3			         ret                           ;return
				;---------------------------------------
				         end
						 
 
Microsoft (R) Macro Assembler Version 6.11		    10/22/24 13:52:55
nextval.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 0001	  Word	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	16 Bit	 006C	  Word	  Public  'CODE'	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0002h	 
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
column . . . . . . . . . . . . .	Byte	 0000	  _DATA	
exit . . . . . . . . . . . . . .	L Near	 0067	  _TEXT	
moveDown . . . . . . . . . . . .	L Near	 0030	  _TEXT	
moveD  . . . . . . . . . . . . .	L Near	 0059	  _TEXT	
moveLeft . . . . . . . . . . . .	L Near	 0039	  _TEXT	
moveL  . . . . . . . . . . . . .	L Near	 0061	  _TEXT	
moveRight  . . . . . . . . . . .	L Near	 0027	  _TEXT	
moveR  . . . . . . . . . . . . .	L Near	 0051	  _TEXT	
moveUp . . . . . . . . . . . . .	L Near	 0042	  _TEXT	
moveU  . . . . . . . . . . . . .	L Near	 0049	  _TEXT	
moves  . . . . . . . . . . . . .	L Near	 0018	  _TEXT	
nextval  . . . . . . . . . . . .	L Near	 0000	  _TEXT	Public

	   0 Warnings
	   0 Errors
